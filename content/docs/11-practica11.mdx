---
title: "Pr√°ctica 11"
date: 2025-10-30
order: 11
---

# Pr√°ctica 11: Temporal Feature Engineering

- **Autores:** Joaqu√≠n Batista, Milagros Cancela, Valent√≠n Rodr√≠guez, Alexia Aurrecoechea, Nahuel L√≥pez (G1)
- **Unidad tem√°tica:** UT3 ¬∑ Feature Engineering
- **Tipo:** Pr√°ctica guiada ‚Äì Assignment UT3-11
- **Entorno:** Python ¬∑ Pandas ¬∑ Scikit-learn ¬∑ Matplotlib ¬∑ Seaborn ¬∑ NumPy
- **Dataset:** Online Retail (Kaggle) ¬∑ 397‚ÄØ884 transacciones ¬∑ 4‚ÄØ338 usuarios ¬∑ 18‚ÄØ562 √≥rdenes
- **Fecha:** Octubre 2025
- **Notebook:** Pr√°ctica 11 - Temporal Feature Engineering
- **Tiempo estimado:** 120‚Äì150 minutos

---

## üéØ Objetivos de Aprendizaje

- **Implementar** lag features usando `groupby().shift()` para capturar valores hist√≥ricos sin leakage.
- **Aplicar** rolling y expanding windows para modelar tendencias a corto y largo plazo.
- **Calcular** m√©tricas RFM para entender el comportamiento de recompra.
- **Construir** agregaciones por ventanas temporales (7d, 30d, 90d) que midan actividad reciente.
- **Codificar** variables calend√°ricas con encoding c√≠clico (sin/cos).
- **Evaluar** modelos con validaci√≥n temporal (`TimeSeriesSplit`) previniendo leakage.
- **Comparar** desempe√±o con y sin temporal features.

---

## üìä Dataset y Contexto de Negocio

### Online Retail Dataset

- **Target:** `will_purchase_again` (1 si el cliente compra nuevamente).
- **Distribuci√≥n:** 85.8‚ÄØ% s√≠ ¬∑ 14.2‚ÄØ% no.
- **Per√≠odo:** 2010-12-01 a 2011-12-09 (373 d√≠as).
- **Promedio de √≥rdenes:** 4.27 por usuario (5.99 para recurrentes).

**Escenario:** una empresa de e-commerce necesita anticipar si un cliente realizar√° otra compra. El reto es capturar patrones temporales fieles a la causalidad y evitar usar informaci√≥n futura.

![Exploraci√≥n temporal de √≥rdenes y distribuciones]( /practico11/temporal-exploration-distributions.png )

---

## üî¨ Metodolog√≠as Implementadas

### 1. Preparaci√≥n y agregaci√≥n a nivel orden

```python
df = (
    df_raw.dropna(subset=["CustomerID"])
          .loc[~df_raw["InvoiceNo"].astype(str).str.startswith("C")]
)
df = df[(df["Quantity"] > 0) & (df["UnitPrice"] > 0)]
df["total_amount"] = df["Quantity"] * df["UnitPrice"]
df = df.sort_values(["user_id", "order_date"]).reset_index(drop=True)
```

- Se consolidaron transacciones al nivel `order_id`, generando `cart_size` y `order_total`.
- Se a√±adieron columnas b√°sicas: `order_number`, `days_since_prior_order`.

### 2. Lag features

```python
orders_df["days_since_prior_lag_1"] = (
    orders_df.groupby("user_id")["days_since_prior_order"].shift(1)
)
```

- `groupby().shift()` garantiza historial por usuario y elimina leakage.
- Se generaron lags de 1, 2 y 3 √≥rdenes previas.

### 3. Rolling y expanding windows

```python
orders_df["rolling_cart_mean_3"] = (
    orders_df.groupby("user_id")["cart_size"]
    .shift(1)  # excluye orden actual
    .rolling(window=3, min_periods=1)
    .mean()
    .reset_index(level=0, drop=True)
)
```

- Rolling (3 √≥rdenes) captura tendencias recientes.
- Expanding acumula desde la primera compra para entender el hist√≥rico.

![Comparaci√≥n rolling vs expanding](/practico11/temporal-rolling-vs-expanding.png)

### 4. RFM (Recency, Frequency, Monetary)

- `recency_days`, `frequency_total_orders`, `monetary_avg` y `monetary_total`.
- `monetary_avg` se calcul√≥ con acumulados expandibles para evitar divisiones por cero.

![Distribuci√≥n de m√©tricas RFM](/practico11/temporal-rfm-distributions.png)

### 5. Ventanas temporales (7d, 30d, 90d)

- Conteo y gasto en distintos horizontes (`orders_7d`, `spend_30d`, `orders_90d`, etc.).
- Permiten detectar activaci√≥n o dormancia de clientes.

![Comparaci√≥n de ventanas temporales](/practico11/temporal-time-windows-comparison.png)

### 6. Product diversity

- `unique_products`, `product_diversity_ratio` y m√©tricas derivadas.
- Capturan si el cliente explora o repite productos.

![Diversidad de productos](/practico11/temporal-product-diversity.png)

### 7. Calendar features y encoding c√≠clico

```python
orders_df["hour_sin"] = np.sin(2 * np.pi * orders_df["order_hour_of_day"] / 24)
orders_df["hour_cos"] = np.cos(2 * np.pi * orders_df["order_hour_of_day"] / 24)
```

- Variables binarias (`is_weekend`, `is_month_start`, `is_holiday`) y codificaci√≥n sin/cos para hora, d√≠a y mes.

![Calendar encoding c√≠clico](/practico11/temporal-calendar-cyclic-encoding.png)

### 8. Variables externas (indicadores econ√≥micos)

- `gdp_growth`, `unemployment_rate`, `consumer_confidence` agregadas por mes.
- Solo `ffill` para mantener causalidad.

![Indicadores econ√≥micos y correlaci√≥n]( /practico11/temporal-economic-indicators.png )

### 9. Validaci√≥n temporal y evaluaci√≥n de modelos

- Se utiliz√≥ `TimeSeriesSplit(n_splits=3)` verificando que `train_max < val_min`.
- Comparaci√≥n:
  - **Modelo base (sin temporal):** AUC 0.6625 ¬± 0.0254.
  - **Modelo con temporal:** AUC 0.7204 ¬± 0.0623.
- Mejora absoluta: **+0.0580 AUC (8.7‚ÄØ%)**.

![Comparaci√≥n de performance](/practico11/temporal-model-performance-comparison.png)

### 10. Feature importance

- Feature importance de un Gradient Boosting demostr√≥ que:
  - `product_diversity_ratio`, `recency_days`, `unique_products`, `spend_90d`, `days_since_prior_lag_3` son top 5.
  - Lag/Window features suman 28.8‚ÄØ% de importancia total.

![Importancia de features temporales](/practico11/temporal-feature-importance.png)

---

## üõ°Ô∏è Data Leakage Detection

Checklist aplicado:

- `groupby().shift(1)` en todas las agregaciones temporales.
- Sin `bfill`, solo `ffill`.
- `TimeSeriesSplit` garantizando orden cronol√≥gico.
- Verificaci√≥n de brecha razonable entre train y CV.
- Revisi√≥n manual de top features para descartar columnas filtradas.

Resultado: **no se detect√≥ leakage** en el pipeline.

---

## üéì Conclusiones e Insights

- Temporal features aportaron **+8.7‚ÄØ%** de mejora en AUC.
- Categor√≠as m√°s influyentes:
  - Lag/Window (28.8‚ÄØ%)
  - Diversity (17.1‚ÄØ%)
  - RFM (15.0‚ÄØ%)
- Los features de ventanas temporales permiten identificar cambios recientes.
- La diversidad de productos es un predictor clave de recompra.

### Reglas de oro anti-leakage

- `df.groupby("user")["feature"].shift(1)` antes de cualquier `rolling/expanding`.
- No usar `shift` global sin agrupar.
- Validar siempre con splits temporales.
- Documentar los pasos y versionar el pipeline.

---

## üîç Preguntas de Reflexi√≥n

1. **Ventanas temporales m√°s relevantes:** 30 d√≠as ofreci√≥ mejor balance se√±al/ruido frente a 7 (ruidoso) y 90 (diluido).  
2. **Variables econ√≥micas:** aportaron poco al ser simuladas y de baja resoluci√≥n temporal; su valor crecer√≠a con datos reales y m√°s frecuentes.  
3. **RFM m√°s predictivo:** `recency_days`, seguido de `frequency_total_orders`; `monetary` aporta pero con menor peso.  
4. **Se√±ales de leakage:** ninguna; el monitoreo de gaps, feature importance y revisiones manuales confirm√≥ integridad.  
5. **Deploy diario:** mantener feature store incremental, c√°lculos online de lags/ventanas, versionado de features/modelos, monitoreo continuo y estrategias para cold-start.

---

## üìö Referencias y Recursos

- Kaggle ‚Äì Online Retail Dataset.
- *Feature Engineering for Machine Learning* ‚Äì cap√≠tulo de temporal features.
- Documentaci√≥n de Pandas (operaciones temporales).
- Scikit-learn ‚Äì `TimeSeriesSplit`.
- Framework RFM para e-commerce.

---
